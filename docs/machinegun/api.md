# Интерфейсы

## Woody API

Чтобы клиенты могли как-то работать с описанной концепцией машин с их историями, сигналами и таймерами, и реализовывать произвольную бизнес-логику, machinegun предоставляет программный интерфейс на базе [Woody RPC](/rpc/overview). Протокол этого интерфейса описан в репозитории [machinegun-proto](https://github.com/valitydev/machinegun-proto). Описанная [концепция](concepts.md) и аспекты [модели](implementation.md) сервиса нашли своё прямое воплощение в виде сервисов и структур данных в этом протоколе.


### Основные сервисы

Все основные операции над машинами machinegun предоставляет в виде сервиса, реализующего интерфейс [`Automaton`][1]. Этот интерфейс − обобщённый, в нём нет никаких структур данных, служащих для моделирования конкретных бизнес-процессов. Поэтому клиенту, который желает воспользоваться этим сервисом для решения задач бизнес-логики, нужно предоставить со своей стороны реализации интерфейса [`Processor`][2] для тех [пространств имён](implementation.md#пространства-имён), к которым machinegun будет обращаться для обработки сигналов: инициализаций, вызовов, таймаутов и починок. В конфигурации каждого пространства имён должен быть указан адрес woody-сервиса, выступающего этим самым процессором.

На практике практически всегда один и тот же сервис выступает как клиентом [`Automaton`][1], так и реализацией интерфейса [`Processor`][2]. Например, сервис [hellgate](hellgate.md) предоставляет своим клиентам интерфейс для процессинга инвойсов и платежей, которые моделируются в виде машин в пространстве имён invoice, и предоставляет machinegun реализацию процессора для обработки необходимых бизнес-процессов этих платежей.

[1]: https://github.com/valitydev/machinegun-proto/blob/96f7f11b/proto/state_processing.thrift#L410
[2]: https://github.com/valitydev/machinegun-proto/blob/96f7f11b/proto/state_processing.thrift#L310

### Инициализация

Жизненный цикл тех или иных бизнес-процессов так или иначе обычно начинается с их _создания_ по запросу внешних пользователей. Вызов клиентом machinegun операции `Automaton.Start` приведёт к тому, что machinegun создаст новую машину в указанном пространстве имён, и отправит процессору сигнал [инициализации](concepts.md#инициализация), чтобы наполнить её историю начальными событиями.

```plantuml
!include styles/stylesheet.puml

box Сервис
participant Клиент as C
participant Процессор as H
end box
participant Machinegun as MG

[-> C ++ : Внешний запрос
C -> MG ++ : Automaton.Start(//Args//, //NS//, //ID//)
MG -> MG : Создание машины
MG -> H ++ : Processor.ProcessSignal(«Init», //Args//, //Machine//)
note right of H
//Machine// на данном этапе
содержит пустую историю.
end note
H -> MG -- : (//StateChange//, //Action//)
MG -> MG : Запись изменений\nсостояния\nв надёжное хранилище
MG -> C -- : «Ok»
C ->[ -- : Ответ внешнему клиенту
```

Процессор может в ответе на запрос обработки этого (и любого другого) сигнала посредством `StateChange` добавить в историю любое количество событий и установить произвольный [aux state](implementation.md#aux-state). Эта операция с точки зрения клиента будет _атомарна_ − даже если процессор породил тысячу новых событий, все они появятся в истории одновременно друг с другом и с новым aux state.

Посредством `Action` же процессор может произвести с машиной определённые _действия_.


### Действия

На данный момент одним из таких действий может быть:

1. [Установка таймера](concepts.md#таймеры) на определённый момент времени.

    В указанный момент времени процессор получит запрос на обработку сигнала таймаут, в результате чего также сможет дополнить историю новыми событиями и произвести любые _действия_, например, установить новый таймер. Установка таймера на текущий момент времени (например, на 0 секунд вперёд) заставит machinegun обработать его _как можно быстрее_.

2. Снятие установленного ранее таймера.

    Ручное закрытие кодового замка с механикой автоматического закрытия из [примера](concepts.md#таймеры) должно приводить к сбросу таймера. Чтобы процессор мог реализовать подобные аспекты бизнес-логики и обезопасить себя от необходимости обрабатывать «лишние» сигналы, он может снять действующий таймер. Реализация обеспечивает защиту от гонок: срабатывание таймера в тот момент времени, когда процессор запросил его снятие, гарантированно не породит сигнал таймаута.

3. [Удаление](implementation.md#удаление) машины.

Запросить удаление машины можно даже в момент инициализации, как бы странно это ни звучало. Клиент получит успешный ответ на запрос запуска машины, однако с точки зрения сторонних наблюдателей (например, внешних пользователей) всё будет выглядеть так, как будто такой машины никогда не существовало.

На самом деле процессор может произвести сразу несколько действий с машиной, это дозволяется, однако редко имеет хоть какой-то смысл: не очень понятно, зачем процессору может понадобиться одновременно установить таймер **и** удалить машину.


### Обработка вызовов

Обработка [вызовов](concepts.md#вызовы) в такой схеме распределения ответственностей между сервисами выглядит особенно нетривиально. Не помешает проиллюстрировать происходящее следующей диаграммой.

```plantuml
!include styles/stylesheet.puml

box Сервис
participant Клиент as C
participant Процессор as H
end box
participant Machinegun as MG

[-> C ++ : Внешний запрос
C -> MG ++ : Automaton.Call(//Args//, //MachineDescriptor//)
note right of MG
//MachineDescriptor// говорит о том:
 • Какую машину вызвать?
   Пространство имён и идентификатор.
 • Какие события выбрать?
   Сколько и с какого момента в истории.
end note
MG -> MG : Загрузка машины и её истории
MG -> H ++ : Processor.ProcessCall(//Args//, //Machine//)
note right of H
//Machine// содержит:
 • Запрошенную историю,
 • Aux state,
 • Текущий таймер, если есть.
end note
H -> MG -- : (//Response//, //StateChange//, //Action//)
MG -> MG : Запись изменений\nсостояния\nв надёжное хранилище
MG -> C -- : //Response//
C ->[ -- : Ответ внешнему клиенту
```

Как и в случае с сигналами, в процессе обработки вызова процессор может произвольно изменить состояние (породить новые события) и запросить любые [действия](#действия).

Machinegun берёт на себя ответственность в том числе и за сохранение [woody-контекста](/rpc/contexts) запроса `Automaton.Call` в надёжном хранилище для того, чтобы все последующие запросы к процессору (и как следствие, любых запрашиваемых им в свою очередь woody-сервисов) были связаны воедино. Например, все последующие таймеры и соответствующие запросы к процессору на обработку таймаутов будут иметь тот же woody-контекст. С точки зрения machinegun эти запросы были _порождены_ вызовом машины и причинно связаны с ним, что по сути и отражается в сохранении изначального woody-контекста.


### Обработка таймеров

В отличие от вызовов, у таймеров и порождаемых ими сигналов нет _внешних_ инициаторов, это та активность, ответственность за которую machinegun возлагает полностью на себя. Это в частности значит, что некому сообщить о том, что в процессе обработки сигнала что-то пошло не так, процессор упал или какой-то сервис оказался временно недоступен. А это значит, что кроме самого machinegun некому взять на себя задачу обработки таких таймаутов, которые не удалось обработать ранее.

Именно поэтому machinegun будет пытаться обработать любые таймауты до победного[^1], если те не удалось обработать по причине недоступности процессора или сервисов, скрывающихся за ним. Пока конфигурация соответствующего пространства имён не заставит его окончательно сдастся спустя указанное время[^2], и перевести машину в статус [_упавшей_](implementation.md#падения).

Эту особенность нужно всегда иметь ввиду и учитывать в реализации бизнес-логики в процессоре, особенно ощутимо это влияет на то, как обеспечивается [_идемпотентность_](#идемпотентность) в сервисах, построенных поверх machinegun.

[^1]: Особое внимание в реализации machinegun уделено тому, чтобы повторные попытки обработать таймауты (известные в коде как _timer retries_) не мешали обработке «обычных» таймаутов. Специальный механизм [квотирования](https://github.com/valitydev/machinegun-core/blob/f8600cea/src/mg_core_scheduler.erl#L127-L128) отвечает за то, чтобы повторные попытки не приводили к «голоданию» (starvation) планировщика обычных таймаутов.
[^2]: А точнее по окончании [_политики повторов_](https://github.com/valitydev/machinegun/blob/fb7fbf93/rel_scripts/configurator.escript#L447-L448).


### Обработка нотификаций

TODO


### Неожиданные ошибки

Концепция _неожиданных ошибок_ в Woody RPC служит по сути для того, чтобы просигнализировать клиенту о том, что на стороне вызываемого woody-сервиса произошла такая ситуация, которую невозможно вписать в протокол их общения. Соответственно, возникновение неожиданной ошибки при общении machinegun с процессором приведёт к [падению](implementation.md#падения) машины. Машина упадёт независимо от того, в рамках обработки какого именно сигнала это произошло, даже если это был сигнал починки.


## Подводные камни

Woody RPC − протокол для организации взаимодействия между различными сервисами _по сети_, а это значит, что система из machinegun и какого-либо его клиента представляет собой _распределённую систему_. Подобные системы в общем случае подвержены ситуациям _частичного отказа_, когда только часть компонентов системы в какой-то момент времени не работают или не доступны. В условиях привычных нам компьютерных сетей и операционных систем эти ситуации в общем случае _неразличимы_. Более того, компонент системы может быть доступен, и даже может обрабатывать запросы, но вот ответы на эти запросы могут теряться на обратном пути, и эта ситуация также неотличима от недоступности.

В таких условиях приходится постоянно задумываться о _побочных эффектах_, которые возникают в процессе обработки тех или иных сигналов, и под которыми в общем случае можно понимать действия, приводящие к _изменению состояния_ сторонних (внутренних и внешних) систем.

### Идемпотентность

В этом контексте под идемпотентностью обычно понимается способность системы гарантировать то, что сколько бы раз мы не пытались применить к ней одни и те же побочные эффекты, её состояние от этого измениться только один раз. Это важное свойство системы в условиях распределённости, потому что в случае подозрения на недоступность этой системы оно позволяет безбоязненно повторять запросы к ней неограниченное количество раз, до тех пор, пока система не вернётся на связь и не будет получен окончательный ответ.

Система, которая предоставляет интерфейс с единственной операцией «увеличь такой-то счётчик на единицу», не может обеспечить идемпотентность: любой запрос к ней приведёт к увеличению счётчика, даже если это запрос повторный. Напротив, система с интерфейсом вида «увеличь счётчик на единицу, но только если он равен X» очевидно обеспечивает идемпотентность: только первый успешный запрос из серии повторных сможет увеличить счётчик, остальные же уже никак не будут успешно обработаны, потому что условие увеличения счётчика к этому моменту уже будет _ложно_.

### Идемпотентность и таймеры

Как было сказано ранее, machinegun будет пытаться повторно обработать любой таймер, если процессор оказался недоступен. Многие бизнес-процессы, построенные поверх машин, зачастую устанавливают таймер на _текущий_ момент времени, чтобы дополнить историю необходимыми событиями и сразу после этого продолжить обработку с учётом этих новых событий. Подобное поведение как раз применяется в тех случаях, когда процессор бизнес-процесса совершает какие-то _побочные эффекты_ и хочет зафиксировать их факт или результат, причём так, чтобы обеспечить идемпотентность.

Например, если выбор провайдера услуг в процессе платежа зависит от значения какой-нибудь случайной величины, то либо это значение, либо результат выбора нужно зафиксировать в отдельном событии. Если этого не сделать, то неизбежные падения в процессе обработки или повторные попытки в случае недоступности процессора могут привести к тому, что последующие побочные эффекты в виде списаний средств окажутся **потеряны**.

Для наглядности представим, что алгоритм выбора провайдера услуг выглядит вот так:

```plantuml
!include styles/stylesheet.puml
start
:Бросить двадцатигранный кубик;
if (Выпало 1 или 2?) then (Критануло)
    :Выбрать провайдера **Дорогой**;
    stop
else (Повезло)
    :Выбрать провайдера **Дешёвый**;
    stop
endif
```

Если при таком алгоритме обработчик платежа забудет сохранить результат выбора в виде отдельного события, то может получиться неприятная ситуация:

```plantuml
!include styles/stylesheet.puml
participant Machinegun
participant Обработчик as H
participant Random
participant Дорогой as PExp
participant Дешёвый as PCheap

Machinegun -> H ++ : Сигнал //таймаут//\nИстория платежа
note right of H
    Состояние
    **Пора выбирать провайдера**.
end note
H -> Random ++ : Случайное число
return 1
note right of H
    Критануло.
    Выбран провайдер **Дорогой**.
end note
H -> PExp ++ : Списать средства
return Готово
destroy H

Machinegun -> H ++ : Повтор сигнала //таймаут//
note right of H
    Состояние
    **Пора выбирать провайдера**.
end note
H -> Random ++ : Случайное число
return 19
note right of H: Выбран провайдер **Дешёвый**.
H -> PCheap ++ : Списать средства
return Готово
return Событие **Провайдер Дешёвый**\nСобытие **Средства списаны**

note over PExp STYLE_COLOR_ERROR
    Списание оказалось
    **потеряно**!
end note
```
