# Концепции

## Машина

Machinegun построен вокруг концепции _машины_. _Машина_ − это по сути прижившаяся калька с многим знакомого понятия [finite-state machine](https://en.wikipedia.org/wiki/Finite-state_machine). В рамках этой концепции _машина_ — это процесс, который при поступлении сигналов извне последовательно, раз за разом переходит из одного состояния в другое. Например, процесс платежа можно промоделировать как одну такую машину[^1], которая создаётся в состоянии «платёж создан» и последовательно переходит между состояниями «производится оценка рисков», «производится выбор провайдера услуг», «начато взаимодействие с провайдером» и тому подобными, и завершается в состоянии «проведён успешно» (либо «проведён неуспешно», в зависимости от множества факторов и нашей удачи).

Однако для более плавного погружения в тонкости этой концепции рассмотрим в этой главе в качестве живого примера машину _кодового замка_. Пусть это будет простой механизм, работающий по следующим простым правилам:

* кто угодно может закрыть кодовый замок, установив выбранный им четырёхзначный код;
* кто угодно может открыть кодовый замок, если он укажет код, установленный в момент последнего закрытия.

```plantuml
!include styles/stylesheet.puml
[*] -> Открыт
Открыт -> Закрыт: Установить код 1337
Закрыт: Код 1337
state Ввод <<choice>>
Закрыт --> Ввод: Набрать код
Ввод -> Открыт: Код = 1337?
Ввод -> Закрыт: Код ≠ 1337?
```

Очевидно, что эта машина не имеет конечного состояния, и может находиться в 10001 _разных_ состояниях:

* одно состояние **Открыт**,
* состояние **Закрыт с кодом 0000**,
* состояние **Закрыт с кодом 0001**,
* ...,
* состояние **Закрыт с кодом 9999**.

[^1]: Не помешает отметить, что на текущий момент процесс платежа на самом деле промоделирован как _часть_ одной монструозной машины, представляющей собой [инвойс][1]. Мы считаем это изъяном в изначальной модели и планируем от этого уйти.

[1]: https://valitydev.github.io/swag-payments/#tag/Invoices


### История и состояние

Концепция _машины_ предполагает, что каждый переход из одного состояния в другое может породить некоторое количество _событий_, которые отражают _изменение_ состояния машины. Количество событий ничем не ограничено: машина может и не породить ни одного события, это будет означать, что машина никак не изменила своё состояние. Изменение состояния происходит исключительно за счёт порождения новых событий. Как следствие машина по сути представлена списком событий, которые эта машина породила в процессе всех свершившихся переходов между состояниями. Этот список событий называется _историей_ машины. На данный момент размер истории никак не ограничен, машина может породить любое количество событий в процессе своего жизненного цикла.

Например, _история_ какого-нибудь кодового замка могла бы состоять из следующих событий:

| Порядковый номер | Время порождения    | Данные события |
| ---------------- | ------------------- | -------------- |
| 1                | 2021.08.11 18:20:52 | Замок открыт   |
| 2                | 2021.08.11 18:21:29 | Замок закрыт с кодом 1337 |
| 3                | 2021.08.11 18:22:00 | Замок успешно открыт |
| 4                | 2021.08.11 18:22:17 | Замок закрыт с кодом 0000 |
| 5                | 2021.08.11 18:23:12 | Замок успешно открыт |
| 6                | 2021.08.11 18:27:41 | Замок закрыт с кодом 4242 |

В такой модели задача получения текущего состояния машины сводится к получению истории машины и _реконструкции_ из этой истории представления _состояния_[^2], наиболее подходящего для бизнес-логики клиента.

С теоретической точки зрения _реконструкция_ состояния должна производиться над всей историей машины целиком, но на практике это зачастую не так. Например, если взглянуть на историю кодового замка из примера выше, то становится очевидно, что для получения текущего состояния замка **Закрыт с кодом 4242** достаточно только последнего события с номером 6.

Как раз для таких ситуаций machinegun предоставляет возможность запрашивать историю конкретной машины произвольными фрагментами любой длины, как с начала, так и с конца истории. Например, клиент в зависимости от своих задач может запросить все события с начала истории, или только самое первое событие, или 5 последних событий, или даже все последние события (в этом случае фрагмент будет содержать всю историю машины, только в порядке от самых новых событий к самым старым).

Важно понимать, что это состояние в явном виде нигде не хранится, _состояние_ машины − производный от _истории_ машины набор данных, и ответственность за реконструкцию состояния лежит на клиенте. Это усложняет логику клиента, но при этом позволяет выбирать наиболее удобное для задачи представление, а впоследствии ещё и безболезненно менять это представление.

Чтобы это проиллюстрировать, представим, что в логику кодового замка понадобилось заложить новое правило, которое запрещает закрывать замок с таким кодом, который совпадает с одним из использованных **два** предыдущих раза. Тогда представление _состояния_ замка из примера выше пришлось бы усложнить до структуры из двух элементов:

1. Замок **открыт**
2. Последние использованные коды: [**0000**, **4242**]

...И для его реконструкции понадобилось бы как минимум 4 последних события вместо одного.

!!! tip
    Строго говоря, machinegun не запрещает клиентам порождать такие события, которые по сути представляют непосредственно текущее состояние машины. В случае бизнес-процессов со сложным состоянием это может увеличить требования к объёму хранилища, а клиент теряет возможность безболезненно менять представление состояния.

Кроме того, подобное представление позволяет восстанавливать не только актуальное, но и историческое состояние машины в любой точке её истории. Имея под рукой историю кодового замка из примера выше, мы можем с лёгкостью ответить на следующие вопросы:

* В каком состоянии был замок на момент события 2?

    Для этого достаточно запросить фрагмент истории с первыми двумя событиями и реконструировать из них состояние.

* Был ли замок **закрыт** в 2021.08.11 18:23:00?

    В простейшем варианте для этого нужно запросить всю истории машины, начиная с самого старого, и реконструировать из них состояние до тех пор, пока время очередного события не превысит момент времени в вопросе.

Для клиента это значит, что порядковый номер события в истории машины может _уникально_ идентифицировать определённое и неизменное состояние этой машины, которое действительно с момента появления этого события и до момента появления следующего.

[^2]: В рамках концепции [event sourcing][3] подобное представление зачастую называют [_проекцией_][4], а сам процесс − проецированием.

[3]: https://en.wikipedia.org/wiki/Domain-driven_design#Event_sourcing
[4]: https://developer.ibm.com/articles/event-stream-projections


### Неизменность истории

События в истории машины нельзя изменить. Как следствие, данные не могут «пропасть», будь-то по ошибке или по злому умыслу. В случае реализации тех же платежей как машин в machinegun это для нас значит, что деньги в процессе обработки платежа не могут просто безвозвратно пропасть и оказаться неучтёнными. А если по причине ошибок в реализации каких-то аспектов бизнес-логики это всё же произошло, под рукой всегда будет хоть какая-то история ошибочного платежа, которую можно обработать и исправить допущенные ошибки.


## Жизненный цикл

Переходы машины из одного состояния в другое, которые сопровождаются появлением в её истории новых событий, вызываются некоторыми _сигналами_. Подобные сигналы могут быть как отправлены извне, так и инициированы непосредственно самой машиной. Это в частности означает ещё и то, что машине могут поступить несколько сигналов _одновременно_. При этом у любой машины в любой момент времени может быть только одна история, состоящая из единой последовательности событий, а это значит, что подобные одновременно поступившие сигналы будут обработаны _последовательно_ в каком-то неопределённом порядке. Два или более сигнала не могут обрабатываться одновременно.

_Модель жизненного цикла_ машины включает в себя несколько _классов_ сигналов, которые моделируют наиболее часто встречающиеся на практике активности бизнес-процессов.

### Инициализация

Чтобы начать обслуживание очередного бизнес-процесса, соответствующая ему машина в machinegun должна быть _создана_. Создание запускает обработку самого первого в жизненном цикле машины сигнала _инициализации_, в результате обработки которого в истории машины появляются первые события. В зависимости от особенностей бизнес-процесса, в результате инициализации, как и в результате любого другого перехода между состояниями машины, в истории может и не появиться ни одного события. Например мы могли бы решить, что кодовый замок с пустой историей машины представляет собой замок в состоянии **Открыт**, а раз любой только что созданный замок должен быть изначально открытым, то в процессе инициализации нет необходимости порождать ни одного события.

!!! todo
    Важной деталью является то, что модель machinegun на данный момент различает _отсутствие_ машины и наличие машины с _пустой_ историей. Это как раз то, что позволяет нам моделировать только что созданный открытый кодовый замок через машину с пустой историей. Но строго говоря, это **усложняет** модель: мы могли бы отказаться от этого различия и считать, что отсутствие истории равноценно отсутствию машины, тогда и необходимость в отдельном сигнале инициализации отпала бы сама собой.

В результате обработки сигнала инициализации машина оказывается в статусе пассивного _ожидания_ последующих вызовов или сигналов.


### Вызовы

Любая активность в рамках бизнес-процесса, инициированная извне человеком или автоматической системой, представляется в виде _вызова_[^5] к машине. В результате обработки вызова, как и в результате обработки сигнала, история может дополнится любым количеством событий. Но кроме того в результате обработки должен быть сформирован _ответ_[^6] на вызов, который будет доставлен вызывающей стороне.

Обработка вызова не обязательно предполагает наличие актуального состояния в момент обработки. Клиент может по своей воле и исходя из своих требований решить, что для обработки вызова достаточно какого-то определённого фрагмента истории или история не нужна вовсе.

В примере с кодовым замком его закрытие можно представить вызовом **Закрыть с кодом 1337**, который в зависимости от текущего состояния замка, может:

* Породить событие **Закрыт с кодом 1337** и сформировать ответ **Закрыт успешно**, если замок был **Открыт**.
* Не порождать ни одного события и сформировать ответ **Замок уже закрыт** в ином случае.

При этом для обработки такого вызова как и в предыдущем случае достаточно лишь последнего события в истории машины этого кодового замка.

[^5]: В коде и протоколах это называется _call_.
[^6]: В коде и протоколах это называется _response_.


### Таймеры

Обработка сигналов и вызовов приводит не только к появлению новых событий в истории машины, в результате обработки машина может установить _таймер_ на произвольный момент времени. В установленное время machinegun запустит обработку сигнала _таймаута_ этой машины, в результате чего в истории смогут появиться новые события (или не появиться). Эта возможность по сути делает machinegun _планировщиком_ бизнес-процессов.

Возможность установки таймеров позволила бы для того же пресловутого кодового замка добавить, например, механику автоматического закрытия с последним использованным кодом через какое-то время, скажем 5 минут. В момент каждого успешного открытия нужно просто устанавливать таймер на 5 минут в будущее, а по их истечении в момент обработки пришедшего сигнала таймаута порождать событие закрытия замка с последним кодом закрытия в истории машины.

При этом момент времени таймера ничем не ограничен: он может быть как в будущем, так и в прошлом. Однако даже если таймер установлен на момент в прошлом, machinegun приложит все усилия, чтобы обработать этот таймер как можно скорее. У машины может быть не более одного активного таймера. Если бизнес-логика какой-то машины требует установки нескольких таймеров на разные моменты времени, подобную механику придётся поддерживать на клиенте и сохранять ещё необработанные таймеры в истории машины.

Обработка _таймаута_ по воле клиента может привести к установке нового таймера, подобное поведение ничем не ограничено.


### Нотификации

TODO
