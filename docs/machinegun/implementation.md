# Реализация

## Модель

Machinegun на данный момент представляет собой сервис, написанный на Erlang, и использующий [Riak KV](https://riak.com/products/riak-kv/) в качестве хранилища данных. Изложенная в предыдущей главе концепция нашла более-менее прямое отражение в этой реализации, однако _модель_ машин, выросшая из этой концепции, обросла различными дополнительными понятиями и процессами, призванными покрыть те потребности, которые неизбежно появляются на практике в процессе разработки и эксплуатации системы.


### Идентификаторы

Самая очевидная практическая потребность − это возможность идентифицировать определённую машину. В момент создания каждой машине назначается уникальный идентификатор (id), причём идентификатор назначается _клиентом_, machinegun не берёт на себя смелость автоматически назначать идентификаторы машинам.

Попытка создания машины с идентификатором, который уже назначен другой машине, является ошибкой[^1].

Формат идентификаторов минимально ограничен − это может быть произвольная непустая строка байт длиной не более 1024[^2].

[^1]: Действительно ли так должно быть − ещё открытый вопрос в рамках концепции, см. [todo](../concepts#инициализация).
[^2]: См. [исходный код](https://github.com/valitydev/machinegun-core/blob/f8600cea/src/mg_core_storage.erl#L72-L73).


### Пространства имён

Модель machinegun предполагает то, что одним экземпляром сервиса machinegun может пользоваться сразу несколько разных клиентов с совершенно разными потребностями. Для того, чтобы такие клиенты могли сосуществовать и не нарушать покой друг друга, в модели появились _пространства имён_ (namespaces). В каждом отдельно взятом пространстве имён свои машины со своими идентификаторами, никак не пересекающимися с другими пространствами имён, и как следствие свой отдельный уютный уголок в хранилище данных.

Не помешает отметить, что это значит, что в двух разных пространствах имён могут быть машины с одним и тем же идентификатором (например, `42`). Соответственно только пара из пространства имён и идентификатора в этой модели _уникально_ идентифицирует любую машину в machinegun.

Кроме того любые аспекты конфигурации поведения machinegun, которые рассматриваются далее, определяются на уровне каждого отдельного пространства имён, что позволяет удовлетворять различным потребностям клиентов.

!!! todo
    Весь набор пространств имён описывается **только** в конфигурации сервиса, информации об имеющихся пространствах имён и аспектах их конфигурации в явном виде в хранилище данных нет. Клиент не может просто _удалить_ какое-то пространство имён. Это довольно хрупко, потому как допускает ситуации, когда новый клиент переиспользовал имя существовавшего в далёком прошлом пространства имён, не подозревая об этом, и столкнулся с тем, что в нём, вопреки его ожиданиям и здравому смыслу, уже есть какие-то машины. Если бы пространства имён были частью хранилища, machinegun мог бы предоставлять интерфейс для их явного создания и удаления.


### Репликация событий

Так как все имеющиеся события всех машин в machinegun представляют собой состояние системы[^3], то простая переливка всех появляющихся событий в стороннюю систему равноценна процессу _репликации_ в том смысле, в каком он обычно понимается разработчиками.

!!! todo
    Это _не совсем_ так: некоторые события в жизненном цикле машины уровня непосредственно самого machinegun (например, установка таймеров) не попадают в историю машины. Это немного ограничивает применимость подобной _реплики_: например из неё невозможно полностью воссоздать ещё один экземпляр machinegun. В идеале подобные события должны реплицироваться наряду с историей машины.

На самом деле machinegun предоставляет специальный механизм под названием _event sink_, который и заведует подобной репликацией. Концептуально event sink − это некое надёжное хранилище, в которое machinegun записывает все события _всех_ машин (лог), а клиенты могут их читать с любого момента времени, чтобы строить какое-то своё производное представление о системе. Подобное хранилище должно давать 2 гарантии:

* Лог событий должен быть _неизменяемым_.

    Любой клиент должен иметь возможность перечитывать этот лог с начала времён (с момента самого первого события) и получать _то же самое_ представление о системе.

* События в логе должны иметь _частичный порядок_.

    Клиент должен читать события одной машины из этого логе в том же порядке, в котором они появились в истории машины. При этом события разных машин могут быть прочитаны в произвольном порядке.[^4]

Machinegun на данный момент поддерживает только одну реализацию event sink на базе [Apache Kafka][1]. Для обеспечения частичного порядка в логе partition key записываемого события формируется на основе идентификатора машины.

У каждого пространства имён может быть свой event sink со своими настройками. Например, в случае той же [Apache Kafka][1] каждому пространству имён может соответствовать свой [topic](https://kafka.apache.org/documentation/#intro_concepts_and_terms).

[1]: https://kafka.apache.org/

[^3]: Занудное уточнение: под _системой_ здесь понимается совокупность machinegun и всех клиентов, использующих его для хранения событий и обработки бизнес-процессов.
[^4]: На практике клиентам конечно же гораздо удобнее читать события в порядке, достаточно «близком» к временному порядку появления событий в machinegun.


### Удаление

В архитектуре системы machinegun призван брать на себя роль _операционного_ хранилища данных бизнес-процессов. В операционном хранилище хранятся данные, которые могут понадобиться пользователям системы, то есть тем, кому компания предоставляет услуги, здесь и сейчас. Иными словами machinegun не должен (хоть и может) быть историческим хранилищем данных, таким, в котором хранятся все данные, независимо от потребностей пользователей в них.

Именно поэтому machinegun даёт возможность _удалять_ машины по желанию клиента. Удаление машины приводит и к снятию её активного таймера.

После удаления машины её идентификатор в пространстве имён сразу же можно переиспользовать, и с этим нужно быть осторожным: внешние системы и даже сервисы, которые потребляют события посредством event sink, могут крайне удивиться тому, что состояние одной и той же с их точки зрения машины вдруг изменилось совершенно непредсказуемым образом.

Важный момент: удаление машины в machinegun не приводит и не должно приводить к удалению событий этой машины из event sink, иначе это бы нарушило его гарантии и смысл его существования. Соответственно, можно сделать вывод, что система, которая реализует event sink, в такой модели выполняет роль исторического хранилища.

!!! todo
    На данный момент удаление машины **не приводит** к удалению всех её событий, они остаются в хранилище навечно.

Это немного идёт вразрез с [концепцией](concepts.md) и является по сути некоторым компромиссом между простотой этой самой концепции и практической возможностью хоть как-то управлять объёмом хранилища, а как следствие его отзывчивостью и затратами на поддержку в работоспособном состоянии.


### Падение

В процессе воплощения красивой и простой концепции в реальную жизнь, полную неприятностей, неизбежно приходится столкнуться с тем фактом, что клиенты, которые общаются с machinegun по определённому [протоколу](api.md), могут _нарушить_ этот протокол.  Это прискорбное соображение вынуждает ввести в модель понятие _падения_ (failure) машины: если в процессе взаимодействия machinegun с клиентом тот нарушает протокол (то есть делает что-то _неожиданное_, выходящее из ряда вон), machinegun переводит эту машину в статус _упавшей_ (failed).

Пока машина находится в статусе упавшей, она не может получать и обрабатывать никакие [сигналы](concepts.md#жизненный-цикл), кроме специального сигнала _починки_ (repair). Предполагается, что столь неожиданное происшествие, которое привело к нарушению протокола и падению машины, должно сначала быть исследовано, а его причина устранена. Только после этого клиент может (и должен) починить машину, отправив соответствующий сигнал и породив при необходимости новые события.

!!! note
    На самом деле это предположение сформировалось из практического опыта. В рамках процесса проведения платежа нередки ситуации, когда на финальном шаге общения с провайдером, когда тот должен подтвердить успешное списание денег с плательщика, он вместо этого отвечает каким-то странным, _неожиданным_ ответом. В результате мы оказываемся в ситуации, когда мы не можем достоверно сказать, списались ли деньги или нет, и нам нужно это как-то выяснить.

Починка приводит к возобновлению жизненного цикла машины с того состояния, в котором она была в момент падения. Это в частности значит, что если за то время, пока машина была упавшей, подошёл момент срабатывания таймера, то сразу после починки этот таймер сработает, и machinegun отправит машине сигнал таймаута. Кроме того, таймер не считается обработанным, если в процессе его обработки машина упала, а это значит, что при починке подобных машин machinegun сразу же пошлёт этой машине повторный сигнал таймаута.

!!! todo
    В machinegun нет никаких ограничений по времени на то, сколько машина находится в статусе упавшей. Вкупе с отсутствием легкодоступной информации о том, какие машины на данный момент упавшие и почему, это приводит к тому, что упавшие машины надолго остаются в этом статусе, и их становится всё сложнее починить.
